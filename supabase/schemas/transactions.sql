CREATE TYPE transaction_type AS ENUM ('income', 'expense', 'internal', 'transfer');

CREATE TABLE public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  transacted_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NULL,
  comment TEXT NULL,
  user_id uuid NOT NULL DEFAULT auth.uid (),
  account_id BIGINT NOT NULL,
  transaction_amount NUMERIC NOT NULL,
  transaction_currency_id BIGINT NOT NULL,
  account_amount NUMERIC NOT NULL,
  account_currency_id BIGINT NOT NULL,
  type public.transaction_type NOT NULL DEFAULT 'expense'::transaction_type,
  category_id BIGINT NOT NULL,
  transfer_id uuid NULL,
  CONSTRAINT transactions_pkey PRIMARY KEY (id),
  CONSTRAINT transactions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id),
  CONSTRAINT transactions_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts (id),
  CONSTRAINT transactions_transaction_currency_id_fkey FOREIGN KEY (transaction_currency_id) REFERENCES currencies (id),
  CONSTRAINT transactions_account_currency_id_fkey FOREIGN KEY (account_currency_id) REFERENCES currencies (id),
  CONSTRAINT transactions_category_id_fkey FOREIGN KEY (category_id) REFERENCES categories (id),
  CONSTRAINT transactions_amount_currency_check CHECK (
    (
      (transaction_currency_id <> account_currency_id)
      OR (transaction_amount = account_amount)
    )
  ),
  CONSTRAINT transactions_comment_check CHECK ((LENGTH(comment) <= 100)),
  CHECK (
    (
      type = 'transfer'
      AND transfer_id IS NOT NULL
    )
    OR (
      type <> 'transfer'
      AND transfer_id IS NULL
    )
  )
);

ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;

create policy "Enable users to view their own data only"
on "public"."transactions"
as PERMISSIVE
for SELECT
to authenticated
using (
  (( SELECT auth.uid() AS uid) = user_id)
);

create policy "Enable insert for users based on user_id"
on "public"."transactions"
as PERMISSIVE
for INSERT
to public
with check (
  (select auth.uid()) = user_id
);

CREATE POLICY "Enable update their own data only" ON "public"."transactions" AS PERMISSIVE
FOR UPDATE
  TO authenticated USING (
    (
      user_id = (
        SELECT
          auth.uid () AS uid
      )
    )
  );

create trigger before_update_transaction_trigger BEFORE
update on transactions for EACH row
execute FUNCTION storage.update_updated_at_column ();


CREATE OR REPLACE FUNCTION public.set_transaction_account_currency()
RETURNS TRIGGER 
security invoker
set search_path = ''
AS $$
BEGIN
  -- Отримуємо валюту акаунта з таблиці accounts
  SELECT currency_id INTO NEW.account_currency_id
  FROM public.accounts
  WHERE id = NEW.account_id;

  -- Перевірка: якщо акаунт не знайдено (хоча constraint має це відловити раніше)
  IF NEW.account_currency_id IS NULL THEN
    RAISE EXCEPTION 'Account with id % not found', NEW.account_id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_account_currency_trigger
BEFORE INSERT ON public.transactions
FOR EACH ROW
EXECUTE FUNCTION public.set_transaction_account_currency();