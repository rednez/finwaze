
  create table "public"."monthly_budgets" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "user_id" uuid not null default auth.uid(),
    "budget_month" date not null default (date_trunc('month'::text, (now())::timestamp without time zone))::date,
    "planned_amount" numeric not null,
    "category_id" bigint not null,
    "currency_id" bigint not null
      );


alter table "public"."monthly_budgets" enable row level security;

CREATE UNIQUE INDEX monthly_budgets_pkey ON public.monthly_budgets USING btree (id);

alter table "public"."monthly_budgets" add constraint "monthly_budgets_pkey" PRIMARY KEY using index "monthly_budgets_pkey";

alter table "public"."monthly_budgets" add constraint "monthly_budgets_category_id_fkey" FOREIGN KEY (category_id) REFERENCES public.categories(id) not valid;

alter table "public"."monthly_budgets" validate constraint "monthly_budgets_category_id_fkey";

alter table "public"."monthly_budgets" add constraint "monthly_budgets_currency_id_fkey" FOREIGN KEY (currency_id) REFERENCES public.currencies(id) not valid;

alter table "public"."monthly_budgets" validate constraint "monthly_budgets_currency_id_fkey";

alter table "public"."monthly_budgets" add constraint "monthly_budgets_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."monthly_budgets" validate constraint "monthly_budgets_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_current_month_budgets_by_category(p_currency_code text)
 RETURNS TABLE(category_name text, total_budget numeric)
 LANGUAGE sql
 SET search_path TO ''
AS $function$
  select
    cat.name as category_name,
    sum(mb.planned_amount) as total_budget
  from public.monthly_budgets mb
  join public.categories cat
    on cat.id = mb.category_id
  join public.currencies cur
    on cur.id = mb.currency_id
  where cur.code = p_currency_code
    and mb.budget_month = date_trunc('month', now()::timestamp)::date
  group by cat.name
  order by total_budget desc, category_name asc;
$function$
;

CREATE OR REPLACE FUNCTION public.set_monthly_budget_month_start()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
begin
  if new.budget_month <> date_trunc('month', new.budget_month::timestamp)::date then
    new.budget_month := date_trunc('month', new.budget_month::timestamp)::date;
  end if;
  return new;
end;
$function$
;

grant delete on table "public"."monthly_budgets" to "anon";

grant insert on table "public"."monthly_budgets" to "anon";

grant references on table "public"."monthly_budgets" to "anon";

grant select on table "public"."monthly_budgets" to "anon";

grant trigger on table "public"."monthly_budgets" to "anon";

grant truncate on table "public"."monthly_budgets" to "anon";

grant update on table "public"."monthly_budgets" to "anon";

grant delete on table "public"."monthly_budgets" to "authenticated";

grant insert on table "public"."monthly_budgets" to "authenticated";

grant references on table "public"."monthly_budgets" to "authenticated";

grant select on table "public"."monthly_budgets" to "authenticated";

grant trigger on table "public"."monthly_budgets" to "authenticated";

grant truncate on table "public"."monthly_budgets" to "authenticated";

grant update on table "public"."monthly_budgets" to "authenticated";

grant delete on table "public"."monthly_budgets" to "service_role";

grant insert on table "public"."monthly_budgets" to "service_role";

grant references on table "public"."monthly_budgets" to "service_role";

grant select on table "public"."monthly_budgets" to "service_role";

grant trigger on table "public"."monthly_budgets" to "service_role";

grant truncate on table "public"."monthly_budgets" to "service_role";

grant update on table "public"."monthly_budgets" to "service_role";


  create policy "Enable update their own data only"
  on "public"."accounts"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable update their own data only"
  on "public"."categories"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable update their own data only"
  on "public"."groups"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable insert for users based on user_id"
  on "public"."monthly_budgets"
  as permissive
  for insert
  to public
with check ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable update their own data only"
  on "public"."monthly_budgets"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable users to view their own data only"
  on "public"."monthly_budgets"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable update their own data only"
  on "public"."savings_goals"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable update their own data only"
  on "public"."transactions"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));


CREATE TRIGGER before_insert_monthly_budget_trigger BEFORE INSERT ON public.monthly_budgets FOR EACH ROW EXECUTE FUNCTION public.set_monthly_budget_month_start();

CREATE TRIGGER before_update_monthly_budget_month_trigger BEFORE UPDATE OF budget_month ON public.monthly_budgets FOR EACH ROW EXECUTE FUNCTION public.set_monthly_budget_month_start();

CREATE TRIGGER before_update_monthly_budget_trigger BEFORE UPDATE ON public.monthly_budgets FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();


