create type "public"."account_type" as enum ('regular', 'savings_goal');

create type "public"."savings_goal_status" as enum ('not_started', 'in_progress', 'done', 'cancelled');

create type "public"."transaction_type" as enum ('income', 'expense', 'internal', 'transfer');


  create table "public"."accounts" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "user_id" uuid not null default auth.uid(),
    "currency_id" bigint not null,
    "updated_at" timestamp with time zone,
    "type" public.account_type not null default 'regular'::public.account_type
      );


alter table "public"."accounts" enable row level security;


  create table "public"."categories" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default auth.uid(),
    "group_id" bigint not null,
    "name" text not null,
    "is_system" boolean not null default false
      );


alter table "public"."categories" enable row level security;


  create table "public"."currencies" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "code" text not null,
    "country_name" text not null,
    "numeric_code" smallint not null,
    "name" text not null
      );


alter table "public"."currencies" enable row level security;


  create table "public"."groups" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "user_id" uuid not null default auth.uid(),
    "is_system" boolean not null default false
      );


alter table "public"."groups" enable row level security;


  create table "public"."monthly_budgets" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "user_id" uuid not null default auth.uid(),
    "budget_month" date not null default (date_trunc('month'::text, (now())::timestamp without time zone))::date,
    "planned_amount" numeric not null,
    "category_id" bigint not null,
    "currency_id" bigint not null
      );


alter table "public"."monthly_budgets" enable row level security;


  create table "public"."savings_goals" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default auth.uid(),
    "start_date" date,
    "end_date" date,
    "amount" numeric not null,
    "status" public.savings_goal_status not null default 'not_started'::public.savings_goal_status,
    "account_id" bigint not null
      );


alter table "public"."savings_goals" enable row level security;


  create table "public"."transactions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "transacted_at" timestamp with time zone not null default now(),
    "local_offset" interval not null,
    "updated_at" timestamp with time zone,
    "comment" text,
    "user_id" uuid not null default auth.uid(),
    "account_id" bigint not null,
    "transaction_amount" numeric not null,
    "transaction_currency_id" bigint not null,
    "account_amount" numeric not null,
    "account_currency_id" bigint not null,
    "type" public.transaction_type not null default 'expense'::public.transaction_type,
    "category_id" bigint not null,
    "transfer_id" uuid
      );


alter table "public"."transactions" enable row level security;

CREATE UNIQUE INDEX accounts_pkey ON public.accounts USING btree (id);

CREATE UNIQUE INDEX categories_pkey ON public.categories USING btree (id);

CREATE UNIQUE INDEX currencies_code_key ON public.currencies USING btree (code);

CREATE UNIQUE INDEX currencies_pkey ON public.currencies USING btree (id);

CREATE UNIQUE INDEX groups_pkey ON public.groups USING btree (id);

CREATE UNIQUE INDEX monthly_budgets_pkey ON public.monthly_budgets USING btree (id);

CREATE UNIQUE INDEX savings_goals_account_id_key ON public.savings_goals USING btree (account_id);

CREATE UNIQUE INDEX savings_goals_pkey ON public.savings_goals USING btree (id);

CREATE UNIQUE INDEX transactions_pkey ON public.transactions USING btree (id);

alter table "public"."accounts" add constraint "accounts_pkey" PRIMARY KEY using index "accounts_pkey";

alter table "public"."categories" add constraint "categories_pkey" PRIMARY KEY using index "categories_pkey";

alter table "public"."currencies" add constraint "currencies_pkey" PRIMARY KEY using index "currencies_pkey";

alter table "public"."groups" add constraint "groups_pkey" PRIMARY KEY using index "groups_pkey";

alter table "public"."monthly_budgets" add constraint "monthly_budgets_pkey" PRIMARY KEY using index "monthly_budgets_pkey";

alter table "public"."savings_goals" add constraint "savings_goals_pkey" PRIMARY KEY using index "savings_goals_pkey";

alter table "public"."transactions" add constraint "transactions_pkey" PRIMARY KEY using index "transactions_pkey";

alter table "public"."accounts" add constraint "accounts_currency_id_fkey" FOREIGN KEY (currency_id) REFERENCES public.currencies(id) not valid;

alter table "public"."accounts" validate constraint "accounts_currency_id_fkey";

alter table "public"."accounts" add constraint "accounts_name_check" CHECK ((length(name) <= 30)) not valid;

alter table "public"."accounts" validate constraint "accounts_name_check";

alter table "public"."accounts" add constraint "accounts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."accounts" validate constraint "accounts_user_id_fkey";

alter table "public"."categories" add constraint "categories_group_id_fkey" FOREIGN KEY (group_id) REFERENCES public.groups(id) not valid;

alter table "public"."categories" validate constraint "categories_group_id_fkey";

alter table "public"."categories" add constraint "categories_name_check" CHECK ((length(name) <= 25)) not valid;

alter table "public"."categories" validate constraint "categories_name_check";

alter table "public"."categories" add constraint "categories_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."categories" validate constraint "categories_user_id_fkey";

alter table "public"."currencies" add constraint "currencies_code_check" CHECK ((code ~ '^[A-Z]{3}$'::text)) not valid;

alter table "public"."currencies" validate constraint "currencies_code_check";

alter table "public"."currencies" add constraint "currencies_code_key" UNIQUE using index "currencies_code_key";

alter table "public"."currencies" add constraint "currencies_name_check" CHECK ((length(name) < 50)) not valid;

alter table "public"."currencies" validate constraint "currencies_name_check";

alter table "public"."groups" add constraint "groups_name_check" CHECK ((length(name) <= 25)) not valid;

alter table "public"."groups" validate constraint "groups_name_check";

alter table "public"."groups" add constraint "groups_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."groups" validate constraint "groups_user_id_fkey";

alter table "public"."monthly_budgets" add constraint "monthly_budgets_category_id_fkey" FOREIGN KEY (category_id) REFERENCES public.categories(id) not valid;

alter table "public"."monthly_budgets" validate constraint "monthly_budgets_category_id_fkey";

alter table "public"."monthly_budgets" add constraint "monthly_budgets_currency_id_fkey" FOREIGN KEY (currency_id) REFERENCES public.currencies(id) not valid;

alter table "public"."monthly_budgets" validate constraint "monthly_budgets_currency_id_fkey";

alter table "public"."monthly_budgets" add constraint "monthly_budgets_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."monthly_budgets" validate constraint "monthly_budgets_user_id_fkey";

alter table "public"."savings_goals" add constraint "savings_goals_account_id_fkey" FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE not valid;

alter table "public"."savings_goals" validate constraint "savings_goals_account_id_fkey";

alter table "public"."savings_goals" add constraint "savings_goals_account_id_key" UNIQUE using index "savings_goals_account_id_key";

alter table "public"."savings_goals" add constraint "savings_goals_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."savings_goals" validate constraint "savings_goals_user_id_fkey";

alter table "public"."transactions" add constraint "transactions_account_currency_id_fkey" FOREIGN KEY (account_currency_id) REFERENCES public.currencies(id) not valid;

alter table "public"."transactions" validate constraint "transactions_account_currency_id_fkey";

alter table "public"."transactions" add constraint "transactions_account_id_fkey" FOREIGN KEY (account_id) REFERENCES public.accounts(id) not valid;

alter table "public"."transactions" validate constraint "transactions_account_id_fkey";

alter table "public"."transactions" add constraint "transactions_amount_currency_check" CHECK (((transaction_currency_id <> account_currency_id) OR (transaction_amount = account_amount))) not valid;

alter table "public"."transactions" validate constraint "transactions_amount_currency_check";

alter table "public"."transactions" add constraint "transactions_category_id_fkey" FOREIGN KEY (category_id) REFERENCES public.categories(id) not valid;

alter table "public"."transactions" validate constraint "transactions_category_id_fkey";

alter table "public"."transactions" add constraint "transactions_check" CHECK ((((type = 'transfer'::public.transaction_type) AND (transfer_id IS NOT NULL)) OR ((type <> 'transfer'::public.transaction_type) AND (transfer_id IS NULL)))) not valid;

alter table "public"."transactions" validate constraint "transactions_check";

alter table "public"."transactions" add constraint "transactions_comment_check" CHECK ((length(comment) <= 100)) not valid;

alter table "public"."transactions" validate constraint "transactions_comment_check";

alter table "public"."transactions" add constraint "transactions_transaction_currency_id_fkey" FOREIGN KEY (transaction_currency_id) REFERENCES public.currencies(id) not valid;

alter table "public"."transactions" validate constraint "transactions_transaction_currency_id_fkey";

alter table "public"."transactions" add constraint "transactions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."transactions" validate constraint "transactions_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_default_user_categories()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  begin
    INSERT INTO public.groups (user_id, name, is_system) 
    SELECT 
        NEW.id,
        'internal',                                   
        true;
    INSERT INTO public.categories (user_id, group_id, name, is_system)
    SELECT
        NEW.id, 
        public.groups.id, 
        'internal', 
        true 
    FROM public.groups
    WHERE public.groups.user_id = NEW.id AND public.groups.name = 'internal';

    return NEW;
  end;
  $function$
;

CREATE OR REPLACE FUNCTION public.get_current_month_budgets_by_category(p_currency_code text)
 RETURNS TABLE(category_name text, total_budget numeric)
 LANGUAGE sql
 SET search_path TO ''
AS $function$
  select
    cat.name as category_name,
    sum(mb.planned_amount) as total_budget
  from public.monthly_budgets mb
  join public.categories cat
    on cat.id = mb.category_id
  join public.currencies cur
    on cur.id = mb.currency_id
  where cur.code = p_currency_code
    and mb.budget_month = date_trunc('month', now()::timestamp)::date
  group by cat.name
  order by total_budget desc, category_name asc;
$function$
;

CREATE OR REPLACE FUNCTION public.get_dashboard_totals(p_currency_code text)
 RETURNS TABLE(total_balance numeric, monthly_income numeric, monthly_expense numeric, previous_total_balance numeric, previous_monthly_income numeric, previous_monthly_expense numeric)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
declare
    v_currency_id bigint;
begin
    select id into v_currency_id
    from public.currencies
    where code = p_currency_code;

    return query
    select
        -- BALANCE (entire period)
        coalesce(sum(t.account_amount), 0) as total_balance,

        -- INCOME (current month)
        coalesce(sum(
            case
                when t.account_amount > 0
                 and (t.transacted_at + t.local_offset) >= date_trunc('month', now())
                 and (t.transacted_at + t.local_offset) < date_trunc('month', now()) + interval '1 month'
                then t.account_amount
            end
        ), 0) as monthly_income,

        -- EXPENSE (current month)
        coalesce(sum(
            case
                when t.account_amount < 0
                 and (t.transacted_at + t.local_offset) >= date_trunc('month', now())
                 and (t.transacted_at + t.local_offset) < date_trunc('month', now()) + interval '1 month'
                then t.account_amount
            end
        ), 0) as monthly_expense,


        -- BALANCE (up to previous month end)
        coalesce(sum(
            case
                when (t.transacted_at + t.local_offset) < date_trunc('month', now())
                then t.account_amount
            end
        ), 0) as previous_total_balance,

        -- INCOME (previous month)
        coalesce(sum(
            case
                when t.account_amount > 0
                 and (t.transacted_at + t.local_offset) >= date_trunc('month', now()) - interval '1 month'
                 and (t.transacted_at + t.local_offset) < date_trunc('month', now())
                then t.account_amount
            end
        ), 0) as previous_monthly_income,

        -- EXPENSE (previous month)
        coalesce(sum(
            case
                when t.account_amount < 0
                 and (t.transacted_at + t.local_offset) >= date_trunc('month', now()) - interval '1 month'
                 and (t.transacted_at + t.local_offset) < date_trunc('month', now())
                then t.account_amount
            end
        ), 0) as previous_monthly_expense

    from public.transactions t
    where t.account_currency_id = v_currency_id
      and t.type <> 'transfer';
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_filtered_transactions(p_category_ids bigint[] DEFAULT NULL::bigint[], p_account_ids bigint[] DEFAULT NULL::bigint[], p_account_currency_codes text[] DEFAULT NULL::text[], p_transaction_currency_codes text[] DEFAULT NULL::text[], p_month date DEFAULT NULL::date, p_page integer DEFAULT 1, p_page_size integer DEFAULT NULL::integer)
 RETURNS TABLE(id bigint, transacted_at timestamp with time zone, local_offset interval, transaction_amount numeric, transaction_currency_code text, account_name text, account_amount numeric, account_currency_code text, exchange_rate numeric, type public.transaction_type, category_name text, group_name text, comment text)
 LANGUAGE sql
 SET search_path TO ''
AS $function$
  select
    t.id,
    t.transacted_at,
    t.local_offset,
    t.transaction_amount,
    tc.code as transaction_currency_code,
    acc.name as account_name,
    t.account_amount,
    ac.code as account_currency_code,
    (t.account_amount / nullif(t.transaction_amount, 0)) as exchange_rate,
    t.type,
    cat.name as category_name,
    cg.name as group_name,
    t.comment
  from public.transactions t
  join public.accounts acc
    on acc.id = t.account_id
  join public.currencies ac
    on ac.id = t.account_currency_id
  join public.currencies tc
    on tc.id = t.transaction_currency_id
  join public.categories cat
    on cat.id = t.category_id
  join public.groups cg
    on cg.id = cat.group_id
  where t.type <> 'transfer'
    and (
      p_category_ids is null
      or cardinality(p_category_ids) = 0
      or t.category_id = any(p_category_ids)
    )
    and (
      p_account_ids is null
      or cardinality(p_account_ids) = 0
      or t.account_id = any(p_account_ids)
    )
    and (
      p_account_currency_codes is null
      or cardinality(p_account_currency_codes) = 0
      or ac.code = any(p_account_currency_codes)
    )
    and (
      p_transaction_currency_codes is null
      or cardinality(p_transaction_currency_codes) = 0
      or tc.code = any(p_transaction_currency_codes)
    )
    and (
      p_month is null
      or (
        (t.transacted_at + t.local_offset) >= date_trunc('month', p_month::timestamp)
        and (t.transacted_at + t.local_offset) < date_trunc('month', p_month::timestamp) + interval '1 month'
      )
    )
  order by (t.transacted_at + t.local_offset) desc, t.id desc
  limit case when p_page_size is null then null else greatest(p_page_size, 1) end
  offset case when p_page_size is null then 0 else (greatest(coalesce(p_page, 1), 1) - 1) * greatest(p_page_size, 1) end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_monthly_cash_flow(p_currency_code text, p_months integer DEFAULT 6)
 RETURNS TABLE(month timestamp with time zone, total_income numeric, total_expense numeric)
 LANGUAGE sql
 SET search_path TO ''
AS $function$
  select
    date_trunc('month', (t.transacted_at + t.local_offset)) as month,
    sum(case when t.account_amount > 0 then t.account_amount else 0 end) as total_income,
    sum(case when t.account_amount < 0 then t.account_amount else 0 end) as total_expense
  from public.transactions t
  join public.currencies c
    on c.id = t.account_currency_id
  where c.code = p_currency_code
    and t.type <> 'transfer'
    and (t.transacted_at + t.local_offset) >= date_trunc('month', now()) 
        - make_interval(months => p_months - 1)
  group by date_trunc('month', (t.transacted_at + t.local_offset))
  order by month;
$function$
;

CREATE OR REPLACE FUNCTION public.get_recent_transactions(p_limit integer DEFAULT 10)
 RETURNS TABLE(id bigint, transacted_at timestamp with time zone, local_offset interval, transaction_amount numeric, transaction_currency_code text, account_name text, account_amount numeric, account_currency_code text, exchange_rate numeric, type public.transaction_type, category_name text, group_name text, comment text)
 LANGUAGE sql
 SET search_path TO ''
AS $function$
  select
    t.id,
    t.transacted_at,
    t.local_offset,
    t.transaction_amount,
    tc.code as transaction_currency_code,
    acc.name as account_name,
    t.account_amount,
    ac.code as account_currency_code,
    (t.account_amount / nullif(t.transaction_amount, 0)) as exchange_rate,
    t.type,
    cat.name as category_name,
    cg.name as group_name,
    t.comment
  from public.transactions t
  join public.accounts acc
    on acc.id = t.account_id
  join public.currencies ac
    on ac.id = t.account_currency_id
  join public.currencies tc
    on tc.id = t.transaction_currency_id
  join public.categories cat
    on cat.id = t.category_id
  join public.groups cg
    on cg.id = cat.group_id
  where t.type <> 'transfer'
  order by (t.transacted_at + t.local_offset) desc, t.id desc
  limit greatest(coalesce(p_limit, 10), 1);
$function$
;

CREATE OR REPLACE FUNCTION public.get_savings_goal_balances(p_limit integer DEFAULT 20)
 RETURNS TABLE(id bigint, name text, currency_code text, start_date date, end_date date, status public.savings_goal_status, amount numeric, balance numeric)
 LANGUAGE sql
 SET search_path TO ''
AS $function$
  select
    acc.id,
    acc.name,
    cur.code as currency_code,
    sg.start_date,
    sg.end_date,
    sg.status,
    sg.amount,
    coalesce(sum(t.account_amount), 0) as balance
  from public.accounts acc
  join public.currencies cur
    on cur.id = acc.currency_id
  join public.savings_goals sg
    on sg.account_id = acc.id
  left join public.transactions t
    on t.account_id = acc.id
  where acc.type = 'savings_goal'
  group by acc.id, acc.name, cur.code, sg.start_date, sg.end_date, sg.amount, sg.status
  order by acc.created_at desc
  limit greatest(coalesce(p_limit, 20), 1);
$function$
;

CREATE OR REPLACE FUNCTION public.make_transfer(p_from_account bigint, p_to_account bigint, p_from_amount numeric, p_to_amount numeric DEFAULT NULL::numeric, p_comment text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  tid uuid := gen_random_uuid();
  from_currency_id BIGINT;
  to_currency_id BIGINT;
  actual_to_amount NUMERIC;
  internal_category_id BIGINT;
BEGIN
  IF p_from_amount IS NULL OR p_from_amount <= 0 THEN
    RAISE EXCEPTION 'Transfer amount must be greater than 0';
  END IF;

  IF p_from_account IS NULL OR p_to_account IS NULL THEN
    RAISE EXCEPTION 'Both source and destination accounts are required';
  END IF;

  IF p_from_account = p_to_account THEN
    RAISE EXCEPTION 'Source and destination accounts must be different';
  END IF;

  SELECT a.currency_id
  INTO from_currency_id
  FROM public.accounts a
  WHERE a.id = p_from_account;

  IF from_currency_id IS NULL THEN
    RAISE EXCEPTION 'Source account % does not exist', p_from_account;
  END IF;

  SELECT a.currency_id
  INTO to_currency_id
  FROM public.accounts a
  WHERE a.id = p_to_account;

  IF to_currency_id IS NULL THEN
    RAISE EXCEPTION 'Destination account % does not exist', p_to_account;
  END IF;

  SELECT c.id
  INTO internal_category_id
  FROM public.categories c
  WHERE c.name = 'internal';

  IF internal_category_id IS NULL THEN
    RAISE EXCEPTION 'Internal category not found';
  END IF;

  -- For single-currency transfers, to_amount defaults to from_amount
  actual_to_amount := COALESCE(p_to_amount, p_from_amount);

  IF actual_to_amount <= 0 THEN
    RAISE EXCEPTION 'Destination amount must be greater than 0';
  END IF;

  INSERT INTO public.transactions (account_id, transaction_amount, account_amount, type, category_id, transfer_id, comment, transaction_currency_id)
  VALUES (p_from_account, -p_from_amount, -p_from_amount, 'transfer', internal_category_id, tid, p_comment, from_currency_id);

  INSERT INTO public.transactions (account_id, transaction_amount, account_amount, type, category_id, transfer_id, comment, transaction_currency_id)
  VALUES (p_to_account, actual_to_amount, actual_to_amount, 'transfer', internal_category_id, tid, p_comment, to_currency_id);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_monthly_budget_month_start()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
begin
  if new.budget_month <> date_trunc('month', new.budget_month::timestamp)::date then
    new.budget_month := date_trunc('month', new.budget_month::timestamp)::date;
  end if;
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.set_transaction_account_currency()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  -- Отримуємо валюту акаунта з таблиці accounts
  SELECT currency_id INTO NEW.account_currency_id
  FROM public.accounts
  WHERE id = NEW.account_id;

  -- Перевірка: якщо акаунт не знайдено (хоча constraint має це відловити раніше)
  IF NEW.account_currency_id IS NULL THEN
    RAISE EXCEPTION 'Account with id % not found', NEW.account_id;
  END IF;

  RETURN NEW;
END;
$function$
;

grant delete on table "public"."accounts" to "anon";

grant insert on table "public"."accounts" to "anon";

grant references on table "public"."accounts" to "anon";

grant select on table "public"."accounts" to "anon";

grant trigger on table "public"."accounts" to "anon";

grant truncate on table "public"."accounts" to "anon";

grant update on table "public"."accounts" to "anon";

grant delete on table "public"."accounts" to "authenticated";

grant insert on table "public"."accounts" to "authenticated";

grant references on table "public"."accounts" to "authenticated";

grant select on table "public"."accounts" to "authenticated";

grant trigger on table "public"."accounts" to "authenticated";

grant truncate on table "public"."accounts" to "authenticated";

grant update on table "public"."accounts" to "authenticated";

grant delete on table "public"."accounts" to "service_role";

grant insert on table "public"."accounts" to "service_role";

grant references on table "public"."accounts" to "service_role";

grant select on table "public"."accounts" to "service_role";

grant trigger on table "public"."accounts" to "service_role";

grant truncate on table "public"."accounts" to "service_role";

grant update on table "public"."accounts" to "service_role";

grant delete on table "public"."categories" to "anon";

grant insert on table "public"."categories" to "anon";

grant references on table "public"."categories" to "anon";

grant select on table "public"."categories" to "anon";

grant trigger on table "public"."categories" to "anon";

grant truncate on table "public"."categories" to "anon";

grant update on table "public"."categories" to "anon";

grant delete on table "public"."categories" to "authenticated";

grant insert on table "public"."categories" to "authenticated";

grant references on table "public"."categories" to "authenticated";

grant select on table "public"."categories" to "authenticated";

grant trigger on table "public"."categories" to "authenticated";

grant truncate on table "public"."categories" to "authenticated";

grant update on table "public"."categories" to "authenticated";

grant delete on table "public"."categories" to "service_role";

grant insert on table "public"."categories" to "service_role";

grant references on table "public"."categories" to "service_role";

grant select on table "public"."categories" to "service_role";

grant trigger on table "public"."categories" to "service_role";

grant truncate on table "public"."categories" to "service_role";

grant update on table "public"."categories" to "service_role";

grant delete on table "public"."currencies" to "anon";

grant insert on table "public"."currencies" to "anon";

grant references on table "public"."currencies" to "anon";

grant select on table "public"."currencies" to "anon";

grant trigger on table "public"."currencies" to "anon";

grant truncate on table "public"."currencies" to "anon";

grant update on table "public"."currencies" to "anon";

grant delete on table "public"."currencies" to "authenticated";

grant insert on table "public"."currencies" to "authenticated";

grant references on table "public"."currencies" to "authenticated";

grant select on table "public"."currencies" to "authenticated";

grant trigger on table "public"."currencies" to "authenticated";

grant truncate on table "public"."currencies" to "authenticated";

grant update on table "public"."currencies" to "authenticated";

grant delete on table "public"."currencies" to "service_role";

grant insert on table "public"."currencies" to "service_role";

grant references on table "public"."currencies" to "service_role";

grant select on table "public"."currencies" to "service_role";

grant trigger on table "public"."currencies" to "service_role";

grant truncate on table "public"."currencies" to "service_role";

grant update on table "public"."currencies" to "service_role";

grant delete on table "public"."groups" to "anon";

grant insert on table "public"."groups" to "anon";

grant references on table "public"."groups" to "anon";

grant select on table "public"."groups" to "anon";

grant trigger on table "public"."groups" to "anon";

grant truncate on table "public"."groups" to "anon";

grant update on table "public"."groups" to "anon";

grant delete on table "public"."groups" to "authenticated";

grant insert on table "public"."groups" to "authenticated";

grant references on table "public"."groups" to "authenticated";

grant select on table "public"."groups" to "authenticated";

grant trigger on table "public"."groups" to "authenticated";

grant truncate on table "public"."groups" to "authenticated";

grant update on table "public"."groups" to "authenticated";

grant delete on table "public"."groups" to "service_role";

grant insert on table "public"."groups" to "service_role";

grant references on table "public"."groups" to "service_role";

grant select on table "public"."groups" to "service_role";

grant trigger on table "public"."groups" to "service_role";

grant truncate on table "public"."groups" to "service_role";

grant update on table "public"."groups" to "service_role";

grant delete on table "public"."monthly_budgets" to "anon";

grant insert on table "public"."monthly_budgets" to "anon";

grant references on table "public"."monthly_budgets" to "anon";

grant select on table "public"."monthly_budgets" to "anon";

grant trigger on table "public"."monthly_budgets" to "anon";

grant truncate on table "public"."monthly_budgets" to "anon";

grant update on table "public"."monthly_budgets" to "anon";

grant delete on table "public"."monthly_budgets" to "authenticated";

grant insert on table "public"."monthly_budgets" to "authenticated";

grant references on table "public"."monthly_budgets" to "authenticated";

grant select on table "public"."monthly_budgets" to "authenticated";

grant trigger on table "public"."monthly_budgets" to "authenticated";

grant truncate on table "public"."monthly_budgets" to "authenticated";

grant update on table "public"."monthly_budgets" to "authenticated";

grant delete on table "public"."monthly_budgets" to "service_role";

grant insert on table "public"."monthly_budgets" to "service_role";

grant references on table "public"."monthly_budgets" to "service_role";

grant select on table "public"."monthly_budgets" to "service_role";

grant trigger on table "public"."monthly_budgets" to "service_role";

grant truncate on table "public"."monthly_budgets" to "service_role";

grant update on table "public"."monthly_budgets" to "service_role";

grant delete on table "public"."savings_goals" to "anon";

grant insert on table "public"."savings_goals" to "anon";

grant references on table "public"."savings_goals" to "anon";

grant select on table "public"."savings_goals" to "anon";

grant trigger on table "public"."savings_goals" to "anon";

grant truncate on table "public"."savings_goals" to "anon";

grant update on table "public"."savings_goals" to "anon";

grant delete on table "public"."savings_goals" to "authenticated";

grant insert on table "public"."savings_goals" to "authenticated";

grant references on table "public"."savings_goals" to "authenticated";

grant select on table "public"."savings_goals" to "authenticated";

grant trigger on table "public"."savings_goals" to "authenticated";

grant truncate on table "public"."savings_goals" to "authenticated";

grant update on table "public"."savings_goals" to "authenticated";

grant delete on table "public"."savings_goals" to "service_role";

grant insert on table "public"."savings_goals" to "service_role";

grant references on table "public"."savings_goals" to "service_role";

grant select on table "public"."savings_goals" to "service_role";

grant trigger on table "public"."savings_goals" to "service_role";

grant truncate on table "public"."savings_goals" to "service_role";

grant update on table "public"."savings_goals" to "service_role";

grant delete on table "public"."transactions" to "anon";

grant insert on table "public"."transactions" to "anon";

grant references on table "public"."transactions" to "anon";

grant select on table "public"."transactions" to "anon";

grant trigger on table "public"."transactions" to "anon";

grant truncate on table "public"."transactions" to "anon";

grant update on table "public"."transactions" to "anon";

grant delete on table "public"."transactions" to "authenticated";

grant insert on table "public"."transactions" to "authenticated";

grant references on table "public"."transactions" to "authenticated";

grant select on table "public"."transactions" to "authenticated";

grant trigger on table "public"."transactions" to "authenticated";

grant truncate on table "public"."transactions" to "authenticated";

grant update on table "public"."transactions" to "authenticated";

grant delete on table "public"."transactions" to "service_role";

grant insert on table "public"."transactions" to "service_role";

grant references on table "public"."transactions" to "service_role";

grant select on table "public"."transactions" to "service_role";

grant trigger on table "public"."transactions" to "service_role";

grant truncate on table "public"."transactions" to "service_role";

grant update on table "public"."transactions" to "service_role";


  create policy "Enable insert for users based on user_id"
  on "public"."accounts"
  as permissive
  for insert
  to public
with check ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable update their own data only"
  on "public"."accounts"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable users to view their own data only"
  on "public"."accounts"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable update their own data only"
  on "public"."categories"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable users to view their own data only"
  on "public"."categories"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable read access for all users"
  on "public"."currencies"
  as permissive
  for select
  to public
using (true);



  create policy "Enable update their own data only"
  on "public"."groups"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable users to view their own data only"
  on "public"."groups"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable insert for users based on user_id"
  on "public"."monthly_budgets"
  as permissive
  for insert
  to public
with check ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable update their own data only"
  on "public"."monthly_budgets"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable users to view their own data only"
  on "public"."monthly_budgets"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable insert for users based on user_id"
  on "public"."savings_goals"
  as permissive
  for insert
  to public
with check ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable update their own data only"
  on "public"."savings_goals"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable users to view their own data only"
  on "public"."savings_goals"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable insert for users based on user_id"
  on "public"."transactions"
  as permissive
  for insert
  to public
with check ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable update their own data only"
  on "public"."transactions"
  as permissive
  for update
  to authenticated
using ((user_id = ( SELECT auth.uid() AS uid)));



  create policy "Enable users to view their own data only"
  on "public"."transactions"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


CREATE TRIGGER before_update_account_trigger BEFORE UPDATE ON public.accounts FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();

CREATE TRIGGER before_insert_monthly_budget_trigger BEFORE INSERT ON public.monthly_budgets FOR EACH ROW EXECUTE FUNCTION public.set_monthly_budget_month_start();

CREATE TRIGGER before_update_monthly_budget_month_trigger BEFORE UPDATE OF budget_month ON public.monthly_budgets FOR EACH ROW EXECUTE FUNCTION public.set_monthly_budget_month_start();

CREATE TRIGGER before_update_monthly_budget_trigger BEFORE UPDATE ON public.monthly_budgets FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();

CREATE TRIGGER before_update_transaction_trigger BEFORE UPDATE ON public.transactions FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();

CREATE TRIGGER set_account_currency_trigger BEFORE INSERT ON public.transactions FOR EACH ROW EXECUTE FUNCTION public.set_transaction_account_currency();

CREATE TRIGGER create_user_trigger AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.create_default_user_categories();


